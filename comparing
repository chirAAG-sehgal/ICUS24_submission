import torch
import torch.nn.functional as F
from yolo8.forward import forward_function
from yolo8.backward import backward_function
from ultralytics import YOLO
import cv2 
import os 
import numpy as np 
import torch
import time 

def dl_model(shelf,model):
    start_time_model = time.time()
    forward_tensor = forward_function(shelf,model)
    backward_tensor = backward_function(shelf,model)
    end_time_model = time.time()
    print(f"Time taken to load both the images  and model: {end_time_model - start_time_model} seconds")

    start_time_algo = time.time()
    if forward_tensor.numel() == 0 or backward_tensor.numel() == 0:
        print("No plant Bed or fruit present")
        print("Total number of fruits = 0")
        exit()
        
    unique_classes, counts = torch.unique(forward_tensor[:, 5], return_counts=True)

    # Filter out the occurrences of class 3
    class_counts_filtered = counts[unique_classes != 3]
    unique_classes_filtered = unique_classes[unique_classes != 3]

    # Check if there are occurrences of the target class
    if unique_classes_filtered.numel() > 0:
        # Set the most occurring class (excluding class 3) as the target class
        most_occuring_class = unique_classes_filtered[class_counts_filtered.argmax()].item()
        target_class = most_occuring_class
        
        # Extract the 7th and 8th columns (coordinates)
        coordinates_forward = forward_tensor[:, 6:8]
        coordinates_backward = backward_tensor[:, 6:8]

        # Get indices where class 3 occurs
        indices_class3_forward = (forward_tensor[:, 5] == 3).nonzero(as_tuple=True)[0]
        indices_class3_backward = (backward_tensor[:, 5] == 3).nonzero(as_tuple=True)[0]

        # Create a list to store tensors for each plant bed
        plant_bed_tensors = []

        # Iterate through the indices to separate plant beds using coordinates
        for i in range(len(indices_class3_forward)):
            if i < len(indices_class3_forward) - 1:
                # Extract rows between two class 3 rows (exclusive)
                plant_bed_tensor_forward = coordinates_forward[indices_class3_forward[i]+1:indices_class3_forward[i+1], :]
                plant_bed_tensor_backward = coordinates_backward[indices_class3_backward[i]+1:indices_class3_backward[i+1], :]
            else:
                # For the last plant bed
                plant_bed_tensor_forward = coordinates_forward[indices_class3_forward[i]+1:, :]
                plant_bed_tensor_backward = coordinates_backward[indices_class3_backward[i]+1:, :]

            # Concatenate forward and backward tensors along rows
            plant_bed_tensor = torch.cat([plant_bed_tensor_forward, plant_bed_tensor_backward], dim=0)

            # Append the plant bed tensor to the list
            plant_bed_tensors.append(plant_bed_tensor)
            
        # Define a function to compare rows and count the number of fruits
        def count_fruits(plant_bed_tensor):
            print(f"PLANT BED = {plant_bed_tensor}")
            num_rows = plant_bed_tensor.shape[0]
            num_fruits = num_rows  # Initialize with the maximum possible number of fruits
            print(f"Num Fruits = {num_fruits}")
            
            # Iterate through all pairs of rows
            for i in range(num_rows):
                for j in range(i + 1, num_rows):
                    # Compute the absolute difference between rows
                    diff = torch.abs(plant_bed_tensor[i, :] - plant_bed_tensor[j, :])
                    print(f"Difference between row {i} and {j} = {diff}")
                    
                    # Set a threshold for considering the rows as the same fruit
                    threshold = 0.04  # You may adjust this threshold based on your data

                    # Check if all elements are less than the threshold
                    if torch.all(diff < threshold):
                        
                        num_fruits -= 1  # Subtract 1 if rows are considered the same fruit
                        print(f"New num fruits = {num_fruits}")
                        
            return num_fruits

        if len(indices_class3_backward) == len(indices_class3_forward):
            if len(indices_class3_backward) == 1:
                plant_bed_1 = plant_bed_tensors[0]
                num_fruits_bed_1 = count_fruits(plant_bed_1)
                print(f"Total fruits = : {num_fruits_bed_1}")
                end_time_algo = time.time()
                print(f"Total time for Algo = {end_time_algo - start_time_algo} seconds")
                return [num_fruits_bed_1 , target_class]

            if len(indices_class3_backward) == 2:
                plant_bed_1 = plant_bed_tensors[0]
                plant_bed_2 = plant_bed_tensors[1]
                num_fruits_bed_1 = count_fruits(plant_bed_1)
                num_fruits_bed_2 = count_fruits(plant_bed_2)
                print(f"Number of fruits in Plant Bed 1: {num_fruits_bed_1}")
                print(f"Number of fruits in Plant Bed 2: {num_fruits_bed_2}")
                print(f"Total fruits = : {num_fruits_bed_1+num_fruits_bed_2}")
                end_time_algo = time.time()
                print(f"Total time for Algo = {end_time_algo - start_time_algo} seconds")
                return [num_fruits_bed_1 + num_fruits_bed_2, target_class]

            if len(indices_class3_backward) == 3:
                plant_bed_1 = plant_bed_tensors[0]
                plant_bed_2 = plant_bed_tensors[1]
                plant_bed_3 = plant_bed_tensors[2]
                num_fruits_bed_1 = count_fruits(plant_bed_1)
                num_fruits_bed_2 = count_fruits(plant_bed_2)
                num_fruits_bed_3 = count_fruits(plant_bed_3)

                # Print the results
                print(f"Number of fruits in Plant Bed 1: {num_fruits_bed_1}")
                print(f"Number of fruits in Plant Bed 2: {num_fruits_bed_2}")
                print(f"Number of fruits in Plant Bed 3: {num_fruits_bed_3}")
                print(f"Total fruits = : {num_fruits_bed_3+num_fruits_bed_1+num_fruits_bed_2}")
                end_time_algo = time.time()
                print(f"Total time for Algo = {end_time_algo - start_time_algo} seconds")
                return [num_fruits_bed_1 + num_fruits_bed_2+num_fruits_bed_3, target_class]
                
        else:
            print(" NUMBER OF PLANT BEDS MISMATCH IN FORWARD AND BACKWARD")
            end_time_algo = time.time()
            print(f"Total time for Algo = {end_time_algo - start_time_algo} seconds")
            return [100000,1000000]
            

    else:
        print("No occurrences of the target class found.")
        end_time_algo = time.time()
        print(f"Total time for Algo = {end_time_algo - start_time_algo} seconds")
        return [0,-1]




